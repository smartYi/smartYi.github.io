{"tags":[{"name":"算法","permalink":"http://www.smartyi8979.com/tags/算法/","url":"/async/tags/算法.json","count":20}],"categories":[{"name":"技术","permalink":"http://www.smartyi8979.com/categories/技术/","url":"/async/categories/技术.json","count":22}],"url":"/async/posts/2016/03/16/LRU2.json","date":1458180516000,"path":{"year":2016,"month":3,"day":16,"name":"LRU2"},"title":"设计一个LRU Cache","permalink":"http://www.smartyi8979.com/2016/03/16/LRU2/","content":"<p>本笔记参考神奕<a href=\"http://songlee24.github.io/2015/05/10/design-LRU-Cache/\" target=\"_blank\" rel=\"external\">博客</a></p>\n<h4 id=\"1-什么是Cache\"><a href=\"#1-什么是Cache\" class=\"headerlink\" title=\"1: 什么是Cache\"></a>1: 什么是Cache</h4><ol>\n<li>概念<br>Cache也就是高速缓存，它是介于CPU和内存之间的一种存储结构，在计算机系统的多级存储结构中，它的访问速度仅次于CPU寄存器。在计算机系统中，CPU的处理速度很快，但是系统对内存的访问以及数据的存取速度远远达不到CPU处理速度，因此高速缓存存在的目的就是减少计算机对内存的访问，使得数据访问速度尽可能的达到CPU处理速度。<a id=\"more\"></a></li>\n<li><p>原理<br>计算机系统对Cache的访问步骤如下:</p>\n<pre><code>* 首先计算机CPU会发出对内存的访问请求；\n* 然后会先查看Cache内是否存在缓存数据，如果有，称为命中，则直接返回数据；\n* 如果Cache命中失败，称为miss，则去访问内存，然后先把内存中的数据存入缓存，再将数据返回处理；\n</code></pre><p>再上面的步骤中，有一个很重要就是当访问miss的时候，从内存取回的数据要存放在Cache中，如果Cache已经占满，那就需要进行数据替换。这就牵扯到Cache的核心－－数据替换策略。</p>\n</li>\n<li>Cache背后的计算机原理<br> 为什么Cache能够实现对数据对快速访问，加大计算机的处理速度。其原因包括：<ul>\n<li>其一：Cache的空间小，因而访问速度快；</li>\n<li>其二：程序执行和数据访问的<strong>局部性原理:</strong><ul>\n<li>时间局部性：如果程序中某条指令被执行，那么很可能不久后该指令还会执行；如果某数据被访问，那么不久后改数据还会被访问；</li>\n<li>空间局部性：程序一旦访问了内存中某个存储单元，那么在不久之后，该存储单元附近的单元也会被访问；也就是说在某一段时间内，程序访问的内存地址集中在一定的范围之内，这是因为在计算机中程序指令和数据存放通常是按照顺序存放的；</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li>替换策略<br>因为Cache的内存有限，因此当内存占满，且访问miss之后，就需要对Cache中的数据进行替换。替换一般有以下几种策略：<ul>\n<li>随机算法(Rand): 由系统产生一个随机数用来确定被替换块。这种方法简单，容易实现，但命中率低；</li>\n<li>先进先出(FIFO)：先进先出算法总是被替换掉的是首先进来对数据块，而不管它是否被使用。因而这种算法不符合局部性原理；</li>\n<li>最久未使用算法(LRU, Least Recently Used)： 这种算法根据Cache中各数据块的使用情况，总是选择最长时间没被使用的数据块替换。这种算法较好的反应了句不行原理；</li>\n<li>最不经常使用(LFU, Least Frequently Used)：将最近一段时间内，访问次数最少的块替换出去；  </li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-Cache的实现\"><a href=\"#2-Cache的实现\" class=\"headerlink\" title=\"2: Cache的实现\"></a>2: Cache的实现</h4><p>Design an LRU Cache with all the operations to be done in O(1).</p>\n<p>对一个Cache的操作一般来说就是三种：插入，查找，替换。<br>因为我们需要实现的是LRU，因此需要维护一个双向链表以保证插入的高效；同时维护链表的表头到表尾是从最近访问到最旧访问顺序。</p>\n<ul>\n<li>插入：因为是双向链表，插入的时候往表头插入，时间O(1);</li>\n<li>替换：当Cache已经占满，删除表尾数据，然后往表头插入新数据；时间复杂度同样为O(1);</li>\n<li>查找：将每次查找到的数据项放到链表头；<br>由于查找需要遍历双向链表，显然违背时间复杂度要求，因此可以同时可以使用一个hash map来实现查找。</li>\n</ul>\n<p>总结一下：<br>要实现一个LRU,要用到两种数据结构；</p>\n<ul>\n<li>双向链表：保证插入和替换的时间复杂度</li>\n<li>hashmap：保证查找的时间复杂度</li>\n</ul>\n<p>看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//先定义双向链表节点</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoubleNode</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> val;<span class=\"comment\">//当前链表存储的数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> key;<span class=\"comment\">//当前node的key</span></span><br><span class=\"line\">\tDoubleNode prev;</span><br><span class=\"line\">\tDoubleNode next;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DoubleNode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.val = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.key = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义双向链表</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoubleLinkedList</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> HashMap&lt;Integer, DoubleNode&gt; map;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> DoubleNode head;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> DoubleNode tail;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DoubleLinkedList</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.capacity = capacity;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tmap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">\t\thead = <span class=\"keyword\">new</span> DoubleNode();<span class=\"comment\">// 两个空节点，单纯的为访问链表</span></span><br><span class=\"line\">\t\ttail = <span class=\"keyword\">new</span> DoubleNode();</span><br><span class=\"line\">\t\thead.next = tail;</span><br><span class=\"line\">\t\thead.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\ttail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\ttail.prev = head;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//首先实现查找方法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (map.get(key) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tDoubleNode cur = map.get(key);</span><br><span class=\"line\">\t\t\tdetach(cur);<span class=\"comment\">//割离这个节点</span></span><br><span class=\"line\">\t\t\tinsertFront(cur);<span class=\"comment\">//从表头插入当前查找节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> cur.val;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//接下来实现访问并设置算法，未满插入，占满替换。</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (map.get(key) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tDoubleNode cur = <span class=\"keyword\">new</span> DoubleNode();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (count == capacity) &#123;</span><br><span class=\"line\">\t\t\t\tdeleteNode();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tnode.key = key;</span><br><span class=\"line\">\t\t\tnode.value = value;</span><br><span class=\"line\">\t\t\tmap.put(key, cur);</span><br><span class=\"line\">\t\t\tinsertFront(cur);</span><br><span class=\"line\">\t\t\tcount++;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tDoubleNode cur = map.get(key);</span><br><span class=\"line\">\t\t\tdetach(cur);</span><br><span class=\"line\">\t\t\tcur.value = value;</span><br><span class=\"line\">\t\t\tinserFront(cur);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//实现删除尾部节点，头部插入节点，以及割离节点方法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">detach</span><span class=\"params\">(DoubleNode cur)</span> </span>&#123;</span><br><span class=\"line\">\t\tcur.prev.next = cur.next;</span><br><span class=\"line\">\t\tcur.next.prev = cur.prev;</span><br><span class=\"line\">\t\tcur.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\tcur.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">insertFront</span><span class=\"params\">(DoubleNode cur)</span> </span>&#123;</span><br><span class=\"line\">\t\tcur.next = head.next;</span><br><span class=\"line\">\t\tcur.prev = head;</span><br><span class=\"line\">\t\thead.next = cur;</span><br><span class=\"line\">\t\tcur.next.prev = cur;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteNode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tDoubleNode cur = tail.prev;</span><br><span class=\"line\">\t\tdetach(cur);</span><br><span class=\"line\">\t\tmap.put(cur.key, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\tcount--;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}