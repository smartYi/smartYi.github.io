{"tags":[{"name":"Leetcode","permalink":"http://www.smartyi8979.com/tags/Leetcode/","url":"/async/tags/Leetcode.json","count":81},{"name":"算法","permalink":"http://www.smartyi8979.com/tags/算法/","url":"/async/tags/算法.json","count":82}],"categories":[{"name":"技术","permalink":"http://www.smartyi8979.com/categories/技术/","url":"/async/categories/技术.json","count":84}],"url":"/async/posts/2016/03/29/House-Robber.json","date":1459277132000,"path":{"year":2016,"month":3,"day":29,"name":"House-Robber"},"title":"House Robber I&&II&&III","permalink":"http://www.smartyi8979.com/2016/03/29/House-Robber/","content":"<h4 id=\"Problem-1\"><a href=\"#Problem-1\" class=\"headerlink\" title=\"Problem 1:\"></a>Problem 1:</h4><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.<br><a id=\"more\"></a></p>\n<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>比较简单的dp题目。解答dp题目重点在于找到状态转移方程。对于本题来说状态转移方程是：</p>\n<p>$$\\(dp[i] = max(dp[i-1], dp[i-2]+cur)\\)$$</p>\n<p>数组dp代表的是抢劫当前house的收益。<br>也就是说对于当前house i来说，我有两种情况：</p>\n<ul>\n<li>进行”抢劫”，那么意味着i－1 house不能抢劫，而应该是在i－2状态下的收益加上当前house的财物；注意我并不在意i－2号房子是否被抢劫，我在意的是i－1号房子不能被抢劫；</li>\n<li>不抢劫当前house，那么我的收益和i－1 house是一样的。</li>\n<li>两者取其大；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(length == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>] &gt; nums[<span class=\"number\">1</span>] ? nums[<span class=\"number\">0</span>] : nums[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            dp[i] = Math.max(dp[i-<span class=\"number\">1</span>], nums[i] + dp[i-<span class=\"number\">2</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[length - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Problem-2\"><a href=\"#Problem-2\" class=\"headerlink\" title=\"Problem 2:\"></a>Problem 2:</h4><p>这一次挑战难度加大了。这次的房子排列成圆形，但是同样的相邻两间房子不能被抢劫。</p>\n<h4 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>既然首尾相连，那么我们就分情况讨论呗：</p>\n<ul>\n<li>假定首house被抢劫，那么尾house就一定不能抢劫；</li>\n<li>假定首house没被抢劫，那么尾house就随便；</li>\n</ul>\n<p>因此维护两个dp数组就好了，一个分别代表一种情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp1 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp2 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];</span><br><span class=\"line\">        dp1[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        dp2[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp1[<span class=\"number\">1</span>] = nums[<span class=\"number\">1</span>];</span><br><span class=\"line\">        dp2[<span class=\"number\">1</span>] = dp2[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            dp1[i] = Math.max(dp1[i - <span class=\"number\">1</span>], dp1[i - <span class=\"number\">2</span>] + nums[i]);</span><br><span class=\"line\">            dp2[i] = Math.max(dp2[i - <span class=\"number\">1</span>], dp2[i - <span class=\"number\">2</span>] + nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//这里由于dp2代表首house被抢劫，因此尾house一定不能被抢劫，但是为了计算方便，上述循环还是存在尾house被抢劫可能性，因此我在这里加一行代码以修正。</span></span><br><span class=\"line\">        dp2[length - <span class=\"number\">1</span>] = dp2[length - <span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(dp1[length - <span class=\"number\">1</span>],dp2[length - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Problem-3\"><a href=\"#Problem-3\" class=\"headerlink\" title=\"Problem 3:\"></a>Problem 3:</h4><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>\n<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>\n<p>这次小偷又发现一个地方可以进行”偷窃”，小偷竟然还分析出来这是一棵二叉树，看样子也是干过程序员的小偷啊。不知道是不是世事艰难，竟干起了这份勾当。不管怎样，他发现这是一棵二叉树式的街道，同样的不能连续偷窃两座house。</p>\n"}