{"tags":[{"name":"算法","permalink":"http://www.smartyi8979.com/tags/算法/","url":"/async/tags/算法.json","count":69}],"categories":[{"name":"技术","permalink":"http://www.smartyi8979.com/categories/技术/","url":"/async/categories/技术.json","count":71}],"url":"/async/posts/2016/03/23/Union-Find算法详解.json","date":1458743463000,"path":{"year":2016,"month":3,"day":23,"name":"Union-Find算法详解"},"title":"Union Find算法详解","permalink":"http://www.smartyi8979.com/2016/03/23/Union-Find算法详解/","content":"<p>本笔记来自于Robert Sedgewick算法中文版第四版。</p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>问题是输入的是一系列整数对，每个整数代表某一种数据类型，一对整数对<code>[p,q]</code>可以理解为“p和q是相连的”，在这里我们定义的相连是一种等价关系：<br><a id=\"more\"></a></p>\n<ul>\n<li>自反性： p和p相连；</li>\n<li>对称性： p和q相连，q和p也相连；</li>\n<li>传递性： p和q相连，q和r相连，那么p和r相连；</li>\n</ul>\n<p>因此通常情况下，我们是来求解所有整数对中的<code>等价类</code>个数。<br>为了讨论的方便，我们规范三个常用的术语：</p>\n<ul>\n<li>触点： 图中的每个对象称为触点；</li>\n<li>连接：每一组整数对称为连接；</li>\n<li>连通分量： 等价类，也就是互相连接的触点；</li>\n</ul>\n<h4 id=\"Union-Find算法的API\"><a href=\"#Union-Find算法的API\" class=\"headerlink\" title=\"Union-Find算法的API\"></a>Union-Find算法的API</h4><table>\n<thead>\n<tr>\n<th>public class UF</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UF(int N)</td>\n<td>以整数(0-(N-1))标示初始化N个触点</td>\n</tr>\n<tr>\n<td>void union(int p, int q)</td>\n<td>在p和q之间添加一条连接</td>\n</tr>\n<tr>\n<td>int find(int p)</td>\n<td>p所在的分量的标示符</td>\n</tr>\n<tr>\n<td>boolean connected(int p, int q)</td>\n<td>如果p和q存在于同一个分量则返回true</td>\n</tr>\n<tr>\n<td>int count()</td>\n<td>连通分量的数量</td>\n</tr>\n</tbody>\n</table>\n<p>在刚一开始我们有N个连通分量，每增加一条连接，就会减1。</p>\n<p>现在我们有了API，那么用何种数据结构实现这种API，在很大程度上决定了算法的效率。由于在API中提到触点和整数对都会用int值表示，那么我们可以用<strong><em>以一个以触点为索引的数组id[]</em></strong>来作为基本的数据结构。一刚开始，我们有N个分量，那么每个触点就有一个自己独有的分量，也就是触点数值本身。那么每进行一次union操作，都会对某个或者某几个触点的标示进行改变，当把整数对操作完毕，调用count返回就直接能够返回连通分量的值。</p>\n<h4 id=\"Union-Find算法的实现\"><a href=\"#Union-Find算法的实现\" class=\"headerlink\" title=\"Union-Find算法的实现\"></a>Union-Find算法的实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UF</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] id;<span class=\"comment\">//分量id，也就是标示,索引是触点值。</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;<span class=\"comment\">//分量数量</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UF</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">\t\tcount = N;</span><br><span class=\"line\">\t\tid = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) id[i] = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">count</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> count;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">connected</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> find(p) == find(q);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//find()和union()看稍后的实现。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这份实现中，我们基本实现了Union-Find的大部分需求，但是关键的两个方法find()和union()还没实现。<br>下面将给出三种不同的实现方法，但是这三种方法都是基于两个触点的标示是否存在统一分量当中。</p>\n<ol>\n<li><p><strong>Quick-Find算法</strong><br> 这种算法的关键在于维护处于同一个分量的触点的标示是一样的。因此这样当我们判断两个触点是否在一个分量中是，可以直接利用<code>id[p] == id[q]</code>.而对于union()方法就有点复杂，首先得先判断是否在同一分量中，如果在同一分量就不进行任何操作；如果不在同一分量当中，将其中任意一个的所有标示等于某一值的触点全部改为另一个标示值。<br> 显然，看得出来，在进行union操作时，需要对id数组进行遍历，而这也是这个方法过慢的原因。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> id[p];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pId = find(p);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> qId = find(q);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pId == qId) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (id[i] == pId) id[i] = qId;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcount--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 这种算法的时间复杂度是\\(O(N^2)\\)。</p>\n</li>\n<li><p><strong>Quick-Union算法</strong><br> 从上面的代码也可以看出，find的时间复杂度是\\(O(1)\\)，而union的复杂度是\\(O(N)\\)。<br> 那么是否有一种方法来进行折衷，使得find不那么快，但是union不那么慢呢？有！那就是quick-union。<br> 同样的id代表触点的标示，但是和之前不同的是，这里的id标示只指向同一个分量中另一个触点的值，当然也有可能是他本身。那么在实现find方法时，我们先通过当前触点的标示得到下一个触点的值，再通过那个触点的标示得到第三个触点的值，直到触点的标示和触点值相同为止，这个触点就称为根触点。因此如果两个触点的根触点是一致的，那么他们俩必定在同一个分量中。同样的实现union方法思路相同。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p != id[p]) p = id[p];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pId = find(p);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> qId = find(q);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pId == qId) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\tid[pId] = qId;</span><br><span class=\"line\">\tcount--;</span><br></pre></td></tr></table></figure>\n<p> 最坏情况下时间复杂度是\\(O(树高)\\)。</p>\n</li>\n<li><p><strong>加权Quick-Union算法</strong><br> 第二种方法看起来已经非常好了，但是正如提到的那样，因为在整个构建树的过程中，你无法知道树的生长过程，因此最终生成的树可能是一棵全是左子树或是右子树的树，那这样就出现了上面的最坏情况。如何避免这种情况，简单修改上述代码就能大大改善这个情况。用的方法就是统计每棵树的数量，每次union的时候，总是把小树往大树上加。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UF</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] id;<span class=\"comment\">//分量id，也就是标示,索引是触点值。</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;<span class=\"comment\">//分量数量</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] size;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UF</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">\t\tcount = N;</span><br><span class=\"line\">\t\tid = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];</span><br><span class=\"line\">\t\tsize = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) id[i] = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) size[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">count</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> count;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">connected</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> find(p) == find(q);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (p != id[p]) p = id[p];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> pId = find(p);</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> qId = find(q);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pId == qId) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (size[pId] &lt; size[qId]) &#123;</span><br><span class=\"line\">\t\t\tid[pId] = qId;</span><br><span class=\"line\">\t\t\tsize[qId] += size[pId];</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tid[qId] = pId;</span><br><span class=\"line\">\t\t\tsize[pId] += size[qId];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcount--;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>union-find在图论中是很重要的一环，温故知新。</p>\n"}