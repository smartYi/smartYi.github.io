{"tags":[{"name":"Leetcode","permalink":"http://www.smartyi8979.com/tags/Leetcode/","url":"/async/tags/Leetcode.json","count":71},{"name":"Google","permalink":"http://www.smartyi8979.com/tags/Google/","url":"/async/tags/Google.json","count":61},{"name":"算法","permalink":"http://www.smartyi8979.com/tags/算法/","url":"/async/tags/算法.json","count":72}],"categories":[{"name":"技术","permalink":"http://www.smartyi8979.com/categories/技术/","url":"/async/categories/技术.json","count":74}],"url":"/async/posts/2016/03/17/Burst-Balloons.json","date":1458259729000,"path":{"year":2016,"month":3,"day":17,"name":"Burst-Balloons"},"title":"Burst Balloons","permalink":"http://www.smartyi8979.com/2016/03/17/Burst-Balloons/","content":"<h4 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h4><p><a href=\"https://leetcode.com/problems/burst-balloons/\" target=\"_blank\" rel=\"external\">Leetcode传送门</a><br>Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] <em> nums[i] </em> nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.<br><a id=\"more\"></a><br>Find the maximum coins you can collect by bursting the balloons wisely.</p>\n<p><strong>Note:</strong>   </p>\n<ol>\n<li>You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.  </li>\n<li>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</li>\n</ol>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>难。肯定是用dp的，又是直觉-__-#。但是如何使用dp又是一个难题。<br>看看总结别人之后的博客，我的思路吧： </p>\n<p><strong>dp[l][r]表示扎破(l, r)范围内所有气球获得的最大硬币数，不含边界；一开始我们对input的nums数组左右两边分别加上1，然后求d[0][n-1]就行 l与r的跨度k从2开始逐渐增大；对于d矩阵我们初始化为0，逐个斜对角线赋值，即l - r == k. 因为只有在k == 2的时候，即[l, r]区间内有一个气球的时候，才会有值，所以从k == 2开始. 我们如何求dp[l][r]呢？这里我们用最后一个气球作为区分点，在(l,r)区间burst 气球的方案可以按最后剩下的那个气球是哪个来区分，如果最后剩下的是第l&lt;i&lt;r个气球，那么dp[l][r]（关于i） = nums[l] <em> nums[i] </em> nums[r] + dp[l][i] + dp[i][r]。因此我们可以选取这些方案中最大的然后再要循环l-r了，这里从第k == 2开始，即在nums上，l从0开始一直到n-k-1, 对应r = k - l</strong></p>\n<p>上面的重点在于以i为区分点。什么意思，也就是位置i的气球是最后一个刺破的，那么这个位置就把问题分成了刺破i左边的气球的得分，和刺破右边气球的得分。</p>\n<p>pretty cool， huh？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxCoins</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] newNums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length + <span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) newNums[i + <span class=\"number\">1</span>] = nums[i];</span><br><span class=\"line\">        newNums[<span class=\"number\">0</span>] = newNums[length + <span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//dp[i][j]代表的是刺破(i,j)之间的气球所能得到的分数。不包含边界。</span></span><br><span class=\"line\">        <span class=\"comment\">//因此我们的目的就是求出dp[0][length+1]。</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length + <span class=\"number\">2</span>][length + <span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">2</span>; k &lt; length + <span class=\"number\">2</span>; k++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>; l &lt; length + <span class=\"number\">2</span> - k; l++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> r = l + k;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = l + <span class=\"number\">1</span>; i &lt; r; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//注意，这里的i的意思是最后一个爆炸的是i位置的气球。</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> cur = newNums[i] * newNums[l] * newNums[r];</span><br><span class=\"line\">                    dp[l][r] = Math.max(dp[l][r], cur + dp[l][i] + dp[i][r]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][length+<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n"}