{"tags":[{"name":"算法","permalink":"http://www.smartyi8979.com/tags/算法/","url":"/async/tags/算法.json","count":52},{"name":"Google","permalink":"http://www.smartyi8979.com/tags/Google/","url":"/async/tags/Google.json","count":50},{"name":"Leetcode","permalink":"http://www.smartyi8979.com/tags/Leetcode/","url":"/async/tags/Leetcode.json","count":50}],"categories":[{"name":"技术","permalink":"http://www.smartyi8979.com/categories/技术/","url":"/async/categories/技术.json","count":54}],"url":"/async/posts/2016/03/17/Super-Ugly-Number.json","date":1458260234000,"path":{"year":2016,"month":3,"day":17,"name":"Super-Ugly-Number"},"title":"Super Ugly Number","permalink":"http://www.smartyi8979.com/2016/03/17/Super-Ugly-Number/","content":"<h4 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem:\"></a>Problem:</h4><p>Write a program to find the nth super ugly number.<br><a id=\"more\"></a><br>Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k.<br>For example, <code>[1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]</code> is the sequence of the first 12 super ugly numbers given primes = <code>[2, 7, 13, 19]</code> of size 4.</p>\n<p><strong>Note:</strong></p>\n<ol>\n<li><code>1</code> is a super ugly number for any given primes.</li>\n<li>The given numbers in primes are in ascending order.</li>\n<li><code>0 &lt; k ≤ 100</code>, <code>0 &lt; n ≤ 106</code>, <code>0 &lt; primes[i] &lt; 1000</code>.</li>\n</ol>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>我们可以通过人工计算第nth个ugly number来进行分析：</p>\n<blockquote>\n<p>题目给出的质数数组是[2,7,13,19],计算ugly number数组。<br>由于数字1永远是ugly number，所以我们先把这个数字放进数组。  </p>\n<ul>\n<li>第二个：将数字1和质数数组中每一个数字相乘，得到的值中取最小的值作为我们的第二个值；这时候结果数组为[1,2…….]</li>\n<li>第三个：第三个的计算和第二个相似，但是区别在于这时候质数2乘以的不再是1了，而是第二步计算得到的2.但是其余质数还是乘以1，因为它们乘以1的结果还没有被结果数组吸收；</li>\n<li>然后继续。。。。。</li>\n</ul>\n</blockquote>\n<p>所以通过上述的分析，重点在于如果当前某个质数的倍数被放进结果数组中，那么下一次计算该质数的倍数是，不应该是原来的那个倍数了，而应该是结果数组中原倍数因子的下一个数。<br>所以我们用一个数组来标记每个质数当前的倍数因子的index，当然最开始都是0，也就是结果数组中的第一个数1；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">nthSuperUglyNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span>[] primes)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span> || n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ret = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        ret[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] indexs = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[primes.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            ret[i] = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; primes.length; j++) &#123;</span><br><span class=\"line\">                ret[i] = Math.min(ret[i], primes[j] * ret[indexs[j]]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; primes.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ret[i] == primes[j] * ret[indexs[j]]) &#123;</span><br><span class=\"line\">                    indexs[j]++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret[n-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解法很巧妙，值得思考。</p>\n"}